variables:
  GIT_DEPTH: 5

stages:
  - deploy-test
  - build-node
  - build-containers
  - push-containers
  - deploy
  - scan-vuln-prepare
  - scan-vuln

.Deploy_template: &deploy
    tags: [docker-asg]
    image: alpine:latest
    before_script:
    # Подготовка SSH-ключей для доступа к серверу из раннера
    - apk add --no-cache openssh
    - eval $(ssh-agent -s)
    - echo "${SSH_KEY}" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "${SSH_KEY}" > ~/.ssh/id_rsa
    - echo -e "Host git.chulakov.org\n\tStrictHostKeyChecking no\n" >> ~/.ssh/config
    - ssh-keyscan $DESTINATION_IP >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - chmod 400 ~/.ssh/id_rsa
    script:
    - echo "${PRJENV}" | tr -d '\r' > ./.env
    - scp -i ~/.ssh/id_rsa ./.env $SSH_USER@$DESTINATION_IP:$DEPLOY_DIR/docker/$CI_ENVIRONMENT_NAME/ && rm -f ./.env
    - ssh -i ~/.ssh/id_rsa $SSH_USER@$DESTINATION_IP "cd $DEPLOY_DIR && $DEPLOY_COMMAND"

Deploy_to_testing:
  stage: deploy-test
  variables:
    SSH_KEY: $STAGE_KEY
    DESTINATION_IP: $STAGE_IP
    SSH_USER: $STAGE_USER
    DEPLOY_DIR: "~/projects/testing/$CI_PROJECT_NAME"
    PRJENV: $ENV_TEST
    DEPLOY_COMMAND: "git fetch && git checkout $CI_COMMIT_BRANCH && git reset --hard origin/$CI_COMMIT_BRANCH && cd docker/$CI_ENVIRONMENT_NAME/ && make install build down up"
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: "on_success"
  environment:
    name: test
  <<: *deploy

Deploy_to_staging:
  stage: deploy
  variables:
    SSH_KEY: $STAGE_KEY
    DESTINATION_IP: $STAGE_IP
    SSH_USER: $STAGE_USER
    DEPLOY_DIR: "~/projects/staging/$CI_PROJECT_NAME"
    PRJENV: $ENV_STAGE
    DEPLOY_COMMAND: "git fetch && git checkout $CI_COMMIT_BRANCH && git reset --hard origin/$CI_COMMIT_BRANCH && cd docker/$CI_ENVIRONMENT_NAME/ && docker-compose pull && make down up"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: prod
  <<: *deploy

#===================================================|
#                    Сборка NEXT.JS                 |
#===================================================|
.Build_nextjs_template: &build-node
  tags: [docker-asg]
  image: node:16-alpine
  before_script:
    - rm -rf build || true
    - mkdir build
    - cp -r src/. build/
  script:
    - cd build
    - npm ci --legacy-peer-deps
    - npm run telemetry
    - npm run build
  artifacts:
    name: $PROJECT-$VERSION-SNAPSHOT-$CI_PIPELINE_ID
    paths:
      - build
    expire_in: 1 hour

# ------------------ Build app-next --------------------------
Build_stage_nextjs:
  stage: build-node
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *build-node

Build_release_nextjs:
  stage: build-node
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: manual
  environment:
    name: prod
  <<: *build-node

#===================================================|
#                  Сборка образов                   |
#===================================================|
.Build_image_template: &build-image
  tags: [docker-asg]
  image: docker:dind
  script:
    - docker build -f $DOCKERFILE
      --build-arg GITLAB_USER_LOGIN=$GITLAB_USER_LOGIN
      --build-arg GITLAB_USER_EMAIL=$GITLAB_USER_EMAIL
      --build-arg CI_COMMIT_REF_NAME=$CI_COMMIT_REF_NAME
      --build-arg CI_COMMIT_SHORT_SHA=$CI_COMMIT_SHORT_SHA
      -t $IMAGE .

# ------------------ Build app-next --------------------------
Build_test_node-front:
  stage: build-containers
  variables:
    DOCKERFILE: "ci/nextjs/Dockerfile"
    IMAGE: "${NEXT_IMAGE_STAGE}"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *build-image

Build_release_node-front:
  stage: build-containers
  variables:
    DOCKERFILE: "ci/nextjs/Dockerfile"
    IMAGE: "${NEXT_IMAGE_PROD}"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: "on_success"
  environment:
    name: prod
  <<: *build-image

# ------------------ Build nginx-next --------------------------
Build_test_nginx-front:
  stage: build-containers
  variables:
    DOCKERFILE: "ci/nginx/Dockerfile"
    IMAGE: "${NGINX_IMAGE_STAGE}"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *build-image

Build_release_nginx-front:
  stage: build-containers
  variables:
    DOCKERFILE: "ci/nginx/Dockerfile"
    IMAGE: "${NGINX_IMAGE_PROD}"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: "on_success"
  environment:
    name: prod
  <<: *build-image

#===================================================|
#            Отправка образов в registry            |
#===================================================|
.Push_image_template: &push-image
  tags: [docker-asg]
  image: docker:dind
  before_script:
    - docker login -u $REGISTRY_LOGIN -p $REGISTRY_PASS $REGISTRY_HOST
  script:
    - docker push $IMAGE

# ------------------ Push app-next --------------------------
Push_test_node-front:
  stage: push-containers
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_STAGE}"
    REGISTRY_PASS: "${REGISTRY_PASS_STAGE}"
    REGISTRY_HOST: "${REGISTRY_HOST_STAGE}"
    IMAGE: "${NEXT_IMAGE_STAGE}"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *push-image

Push_release_node-front:
  stage: push-containers
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_PROD}"
    REGISTRY_PASS: "${REGISTRY_PASS_PROD}"
    REGISTRY_HOST: "${REGISTRY_HOST_PROD}"
    IMAGE: "${NEXT_IMAGE_PROD}"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: "on_success"
  environment:
    name: prod
  <<: *push-image

# ------------------ Push nginx-front --------------------------
Push_test_nginx-front:
  stage: push-containers
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_STAGE}"
    REGISTRY_PASS: "${REGISTRY_PASS_STAGE}"
    REGISTRY_HOST: "${REGISTRY_HOST_STAGE}"
    IMAGE: "${NGINX_IMAGE_STAGE}"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *push-image

Push_release_nginx-front:
  stage: push-containers
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_PROD}"
    REGISTRY_PASS: "${REGISTRY_PASS_PROD}"
    REGISTRY_HOST: "${REGISTRY_HOST_PROD}"
    IMAGE: "${NGINX_IMAGE_PROD}"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: "on_success"
  environment:
    name: prod
  <<: *push-image

#===================================================|
#           Сканирование на уязвимости test         |
#===================================================|
Scan_vulneables_test_prepare:
  stage: scan-vuln-prepare
  tags: [docker-asg]
  image: node:16-alpine
  script:
    - cd src
    - npm ci --legacy-peer-deps
  only:
    - master
  environment:
    name: test
  artifacts:
    name: $PROJECT-$VERSION-SNAPSHOT-$CI_PIPELINE_ID
    paths:
      - src/node_modules
    expire_in: 1 hour

Scan_vulneables_test:
  stage: scan-vuln
  tags: [docker-asg]
  image: 
    name: aquasec/trivy
    entrypoint: [""]
  script:
    - trivy filesystem .
  only:
    - master
  environment:
    name: test


#=====================================|
#         Проверка уязвимостей        |
#=====================================|
.Scan_image_template: &scan-image
  tags: [docker-asg]
  image: 
    name: aquasec/trivy
    entrypoint: [""]
  script:
    - trivy image $NEXT_IMAGE
    - trivy image $NGINX_IMAGE


Scan_test_images:
  stage: scan-vuln
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_STAGE}"
    REGISTRY_PASS: "${REGISTRY_PASS_STAGE}"
    REGISTRY_HOST: "${REGISTRY_HOST_STAGE}"
    NEXT_IMAGE: "${NEXT_IMAGE_STAGE}"
    NGINX_IMAGE: "${NGINX_IMAGE_STAGE}"
  rules:
    - if: '$CI_COMMIT_BRANCH == "release"'
      when: "on_success"
  environment:
    name: stage
  <<: *scan-image

Scan_release_images:
  stage: scan-vuln
  variables:
    REGISTRY_LOGIN: "${REGISTRY_LOGIN_PROD}"
    REGISTRY_PASS: "${REGISTRY_PASS_PROD}"
    REGISTRY_HOST: "${REGISTRY_HOST_PROD}"
    NEXT_IMAGE: "${NEXT_IMAGE_PROD}"
    NGINX_IMAGE: "${NGINX_IMAGE_PROD}"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^[0-9]\.[0-9]+\.[0-9]+$/
      when: "on_success"
  environment:
    name: prod
  <<: *scan-image
