# Next.js 13 boilerplate

## TODO

1. Storybook, Jest? - не то чтобы часто пригождается. Эффективность бизнеса превыше всего
2. Не удалось подключить типизацию локалей. Не видит react-i18next
3. Конфигурация линтеров - легка. Надо придумать кодстайл и на его основе настраивать линтеры.
   Но пока этого нет хватает и практически дефолтный правил.

## Как приступить к работе

### Подготовка

1. Обновить все зависимости и node.js
2. Поправить название и автора в package.json

### Запуск проекта

В директории src команда `pnpm dev`.
Перед перед MR нужно запустить `pnpm build` если ничего не упало то и CI/CD не упадет.
В CI/CD просто запускается команда `npm run build`, в худшем случае локальная версия node.js не совпадает. Просите девопсера поднять версию ноды

## Структура папок

> Меняйте структуру папок до тех пор, пока вам и вашей команде не будет удобно

- components

  - base - минимальные UI компоненты
  - layout - компоненты повторяющиеся на на всех страницах
  - pages - предсобранные страницы
    - partials - если компонент нужен только для одной страницы, он храниться внутри нее
  - shared - крупные компоненты для двух и более страниц
- lib
  - config - конфиги
  - constants - ключи для React-Query, url и т.д
  - mocks - обработчика для [MSW](#Mocks(MSW))
  - models - стабы
  - services - сервисы для работы с запросами
- style
- types - для типов не относящихся к определенному компоненту
- typings - для декларирования модулей. Вспомогательные или переопределение библиотек\
- utils - для хуком и вспомогательных функций

## Технологии

### Пакетный менеджер (PNPM)

PNPM - быстрей yarn и тем более npm. Хранит общий кэш для пакетов на OS, что позволяет экономить место но диске

### Data fetching (React-Query + Axios)

Менеджеры состояний как redux, mobx хорошо работают с состояниями на стороне клиента, но не на стороне сервера. Это связано с тем, что состояние сервера сохраняется удаленно в месте, которое клиентская сторона не может контролировать, оно может устареть, и нам необходимо создать асинхронные API для извлечения и обновления.

React Query — одна из лучших библиотек для управления состоянием сервера. Это помогает нам извлекать, кэшировать, синхронизировать и обновлять данные, не касаясь какого-либо глобального состояния.

- [Practical React Query](https://tkdodo.eu/blog/practical-react-query) - серия качественных статей для обучения
- [React-Query SSR](https://tanstack.com/query/v4/docs/guides/ssr) - подключение в nextjs

**Почему axios, а не fetch?**

- Axios изоморфный
- В axios есть interseptors

### State manager (MST)

> "un-opinionated" section

Каждый инструмент хорош под задачу, но даже это не важно. Но мы в студии не делаем продукты как: figma, miro, facebook, tilda и т.д
Нужды сайтов которые мы делаем практически всегда можно покрыть Context + React Query
Но, если вы чувствуете что неудобно, рекомендую выбирать тот который вы лучше знаете, больше нравиться. Все они хороши
Если опыта со стейт менеджерами нет и все равно какой учить - выбирайте effector. Самый свежий, новационный
По некоторый источникам еще и работать с ним приятно. Решает проблемы предыдущих менеджеров

**redux-toolkit**

- [redux-toolkit](https://redux-toolkit.js.org/)

Есть свой инструмент для работы c API - RTK Query. Некоторые компании уходят от React Query, потому что не могут справиться с инвалидацией. Возвращаются обратно на Redux.
Но вообще не рекомендую. В студии нет таких проектов. Если вы делает проект на котором стало сложно с React Query, то вам не нужна эта readme и вообще вам ничего не нужно, уж все умеете/

**MobX-State-Tree**

- [MobX-State-Tree](https://mobx-state-tree.js.org/intro/welcome)

Улучшенная версия Mobx. На чистом Mobx надо заботиться об архитектуре. Качественный код на Mobx написать сложнее чем на RTK. MobX-State-Tree предоставляет типы и архитектуру

**effector**

- [effector](https://mobx-state-tree.js.org/intro/welcome)
  - [Лучшая часть Эффектора](https://community.effector.dev/core/best-part-4jb1)
  - [Игорь Камышев — Как и зачем мы мигрировали Авиасейлс на Effector](https://www.youtube.com/watch?v=HYaSnVEZiFk)

### I18N (next-i18next)

Интернационализация реализуется встроенный в nextjs [Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config) функционалом и библиотекой [next-i18next](https://github.com/i18next/next-i18next).

### Mocks(MSW)

[Mock Service Worker](https://mswjs.io/) - сервис для моков. Полезно для тестирования, разработки и выявления ошибок

## Линтеры

При коммитах husky запускает:

- prettier, eslint и stylelint для измененных файлов
- commitlint - проверяет правильность написания коммитов по [Commits Convencionales](https://www.conventionalcommits.org/es/v1.0.0-beta.3/).
